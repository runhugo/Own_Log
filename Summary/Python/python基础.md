## 进程和线程
1. python的进程和多线程
```
- 进程是系统分配资源的最小单元，线程是操作系统调度的最小单元。
- 进程之间的数据不共享，进程间通信需要用到Pipe和Queue（multiprocessing库）
- 一个应用至少要有1个进程，1个进程里包含1个或多个线程
- Python中，每个进程都会被系统分配1个Python解释器。进程内部有GIL（全局解释器锁），其一个线程运行时需要霸占python解释器（加了GIL）。因此该线程运行时其他线程无法运行，直至该线程执行完成后释放GIL。当线程执行耗时操作时，则可能释放解释器，让其他线程先运行。
- 综上，多线程运行实际上是线程切换的假象，线程运行仍然是有先后顺序的；多进程是可以实现的，但会耗费资源
```


## 内存
1. Python的内存管理/垃圾回收机制<br>
[Reference1](https://www.zhihu.com/question/30747394)<br>
[Reference2](https://juejin.cn/post/6856235545220415496)
```
内存管理的机制是：引用计数、垃圾回收和内存池的机制

- 引用计数：
一种高效的的内存管理手段。当一个Python对象被引用时其引用计数 +1， 当其不再被一个变量引用时则计数 -1. 当引用计数等于0时对象被删除。

- 垃圾回收：
1. 引用计数
引用计数也是一种垃圾收集机制，而且也是一种最直观，最简单的垃圾收集技术。但如果出现循环引用，引用计数机制就不再起有效的作用了

2. 标记清除
如果两个对象的引用计数都为 1，但是仅仅存在他们之间的循环引用，那么这两个对象都是需要被回收的，也就是说，它们的引用计数虽然表现为非 0，但实际上有效的引用计数为 0。所以先将循环引用摘掉，就会得出这两个对象的有效计数。

3. 分代回收
从前面“标记-清除”这样的垃圾收集机制来看，这种垃圾收集机制所带来的额外操作实际上与系统中总的内存块的数量是相关的，当需要回收的内存块越多时，垃圾检测带来的额外操作就越多，而垃圾回收带来的额外操作就越少；反之，当需回收的内存块越少时，垃圾检测就将比垃圾回收带来更少的额外操作。

e.g: 当某些内存块 M 经过了 3 次垃圾收集的清洗之后还存活时，我们就将内存块 M 划到一个集合 A 中去，而新分配的内存都划分到集合 B 中去。当垃圾收集开始工作时，大多数情况都只对集合 B 进行垃圾回收，而对集合 A 进行垃圾回收要隔相当长一段时间后才进行，这就使得垃圾收集机制需要处理的内存少了，效率自然就提高了。在这个过程中，集合 B 中的某些内存块由于存活时间长而会被转移到集合 A 中，当然，集合 A 中实际上也存在一些垃圾，这些垃圾的回收会因为这种分代的机制而被延迟。

- 内存池：
Python的内存共6层：
1. -1、-2层主要由操作系统操作
2. 第 0 层是 C 中的 malloc，free 等内存分配和释放函数进行操作；
3. 第1、2层是内存池，Python 内部默认的小块内存与大块内存的分界点定在 256 个字节。
    - 第1层：当申请的内存大小大于256KB时，由Python原生的内存分配器进行分配，本质上是调用C标准库中的malloc/realloc等函数
    - 第二层：申请的内存大小小于256KB时，内存分配主要由 Python 对象分配器（Python’s object allocator）实施
4. 第3层：对 Python 对象的直接操作。对于python内置的对象（比如int,dict等）都有独立的私有内存池，对象之间的内存池不共享，即int释放的内存，不会被分配给float使用

![内存池](https://user-gold-cdn.xitu.io/2020/7/14/1734c82253759c7c?imageView2/0/w/1280/h/960/ignore-error/1)
```

## 区别比较
1. Python2.7和Python3.5的区别
```
1. print函数的使用方式不同
2. 使用的编码不同（2.7用ascii，3.+用utf-8）
3. range返回不同，2.7返回list，3.+返回迭代器
4. 2中输入是raw_input，3中是input
5. 除法运算：2中除法，整数相除返回的是一个整形，3中返回的是浮点型
6. 3中用range替代了xrange
```

2. 内置数据结构
```
数值：int float bool complex
集合：list tuple str set dict 
```

3. tuple和list的区别
```
相同：
二者都可以迭代访问内部元素

不同：
- tuple创建后不允许插入和删除（但如果tuple内部元素是list，内部的list可以边，只需要保证指向这个list的地址不变即可）
- list允许插入和删除新数据
```

4. is、==和=的区别
```
=是赋值

is和==都是比较，但：
- is用于判断两个变量对象是否为同一个，相当于id(A)==id(B)
- ==用于判断两个对象的值是否相同

```

5. for和while
```
相同：
for和while都可以处理循环

区别：
- for是在所遍历的序列穷尽时停止；while是循环条件不成立时停止
- for声明循环的变量，while循环时判断循环条件
- for一般不会出现死循环，while容易写成死循环
```

6. 生成器、迭代器和集合（可迭代对象）的区别<br>
[Reference]()
```
- 可迭代对象：
只要该对象实现了__iter__()方法，并且返回的是一个迭代器（下面解释迭代器是什么意思），那么这个对象就叫做可迭代对象。通俗的说就是可以用for循环的对象都是可迭代对象。例如：字符串、列表、元组、字典、集合等等。都是可迭代对象。

- 迭代器：
迭代是python最强大的功能之一，**是访问集合元素的一种方法**。迭代器可以记住遍历对象的位置。迭代器有两个基本方法 iter()、next()
所以可以被next（）函数调用并不断返回下一个值得对象就叫做迭代器（iterator）

迭代器一定是可迭代对象，但是可迭代对象不一定是迭代器。例如：字符串、字典、元组、集合等。
一般可以使用iter（）方法将可迭代对象变成迭代器。

**迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。**

- 生成器：
是一种特殊的迭代器，只能被遍历一次，遍历结束，就自动消失了

使用了 yield 的函数被称为生成器（generator），返回迭代器，只能用于迭代操作
在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下
一次执行 next() 方法时从当前位置继续运行。

**对于一个数据集合，生成器并不记住每个元素值，但在循环中记录元素位置并根据元素生成规则推算出数值，这种边循环边计算的形式是生成器**
```

7. 实例方法、静态方法和类方法
```
- 实例方法：
1. 类中定义的默认是实例方法
2. 最大的特点是，第一个参数一定是self，用于绑定调用此方法的实例对象

- 类方法
1. 需要有classmethod修饰符，没有的话默认为实例方法
2. 至少包含1个参数cls
3. 直接用类名调用，不推荐用实例调用

- 静态方法
1. 静态方法，其实就是我们学过的函数，和函数唯一的区别是，静态方法定义在类这个空间（类命名空间）中，而函数则定义在程序所在的空间（全局命名空间）中。
2. 没有类似 self、cls 这样的特殊参数，因此 Python 解释器不会对它包含的参数做任何类或对象的绑定。也正因为如此，类的静态方法中无法调用任何类属性和类方法。
3. 需要使用＠staticmethod修饰
4. 可以用类名调用，也可以用实例调用
```

8. copy和deepcopy
```
copy：浅拷贝，将A拷贝给B，当A改变时，B也改变，即A和B并不是独立的个体

deepcopy：深拷贝，将A拷贝给B，当A改变时不会影响B，即A和B是两个完全独立的对象
```

9. map函数
```
是python的一个内置函数，会根据提供的函数，对指定的序列做映射

函数可接受1个或多个序列
```

10. 什么时候用多进程？什么时候用多线程？
```
IO密集型和CPU密集型
```

11. 什么是内存泄漏？如何避免？
```
内存泄漏：
1. 内存泄漏指由于疏忽或错误造成程序未能释放已经不再使用的内存。
2. 内存泄漏并非指物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就是去了对该段内存的控制，从而造成了内存的浪费

如何避免？
1. 有__del__函数的对象间的循环引用是导致内存泄漏的主凶
2. 不使用一个对象时，使用del obj来删除一个对象的引用计数就可以有效防止内存泄漏问题

通过python扩展模块gc可以查看不能回收的对象的详细信息
通过sys.getrefcount(obj)来获取对象的引用计数，并根据返回值是否为0来判断是否内存泄漏
```

12. 

