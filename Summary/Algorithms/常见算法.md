## 算法
[Refrence](https://zhuanlan.zhihu.com/p/162729996)

### **1. 递归**
- 一种算法求解的代码实现方式
- 可应用于诸多算法，如快速排序、深度优先搜索(DFS)、二叉树遍历等
- 可使用递归解决的问题：
    1. 1个问题的解可以拆分为子问题的姐
    2. 父问题和子问题，除了数据规模，求解思路要完全一致，即**递推公式**
    3. 存在递归**终止条件**
- 注意事项：
    1. stackoverflow：递归层次太深，可能导致栈溢出
    2. 子问题的重复计算：避免重复计算已解的子问题，可以有效降低时间复杂度

----

### **2. 排序算法**
- 排序算法的本质是排序后，使得序列中的逆序对为0
    - 逆序对：对于数组A，若i<j，但A[i]>A[j]，则A[i]和A[j]即为1对逆序对
- 不同的排序算法消除逆序对的方式不一样，体现在时/空复杂度、排序方式、稳定性、使用场景等
![各种算法的复杂度对比](https://pic2.zhimg.com/v2-49e3a350c6f5448043c5073bbf96d28d_r.jpg)
- 选择排序算法时，要综合考虑算法的执行效率，资源消耗和稳定性等
- 如何分析排序的效率
    1. 最好情况、最坏情况、平均情况的时间复杂度
    2. 时间复杂度的系数、常数、低阶
        - 比如小规模排序是10个、100个还是1000个
    3. 比较次数和交换次数
    4. 内存消耗：原地排序(In-place)和外部排序(Out-place)
        - In-place：空间复杂度为O(1)，即不需要开辟外部空间
        - Out-place：需要开辟空间存储中间状态
    5. 稳定性：带排序列中存在值相等的元素，排序后这些元素的先后顺序是否会改变，不改变即为稳定

#### **冒泡排序**
遍历数组n，对于元素i：
1. 把元素i与i+1进行比较，如果n[i]>n[i+1]，则互换他们的位置，直至最后，则排到最后的一定是元素最大的
2. 从头开始，重复1的比较，遍历剩余的未排序长度的元素
3. 输出排序后的n

#### **选择排序**
遍历数组n：
1. 找到最小的元素i，把它放到最前面
2. 遍历剩余未排序的元素，找到第二小的元素放到已排序的i+1的位置
3. 重复步骤2，直至原数组n全部取出，输出已排序的n

#### **插入排序**
已给数组n：
1. 第1个元素认为是已排序，标记为排序序列o_n
2. 对于未排序的序列n-1，遍历，对元素i：
    - 跟已排序序列的元素逐个对比（从后向前扫描），找到适合插入的位置
    - 重复上述步骤，直至n中所有元素都加入o_n
3. 输出排序后的n即可

#### **快速排序**
给定数组n：
1. 选取一个基准值base（取n[0]或者n[middle]?）
2. 遍历数组n[1:]，对其分区：
    - 如果元素i <= base，添加到less数组
    - 如果元素i > base，添加到larger数组
3. 分别对less和larger再快速排序（递归），直至传入的数组长度为1，直接返回数组
4. 递归返回排序后的数组顺序为less+base+larger
5. 输出最后的排序结果即可

**其他排序算法待学习** <br>
[Leetcode-12种排序算法](https://leetcode-cn.com/problems/sort-an-array/solution/shi-er-chong-pai-xu-suan-fa-bao-ni-man-yi-dai-gift/) <br>
[十大排序算法(动图)](https://www.cnblogs.com/onepixel/articles/7674659.html)

----

### **查找算法**
#### **1. 顺序查找**
- 也称线性查找
- 过程：遍历表内元素，逐个与目标值比较对比，直至找出目标或遍历完毕
- 效率低下

#### **2. 二分查找**
- 也叫折半查找
- 要求：待查找序列要有序
- 过程：
    - 每次将待查找序列中点位置的元素与目标值比较
    - 如果middle==target，则直接返回对应元素或下标
    - 如果middle < target，表明目标可能在middle的右边
    - 如果middle > target，表明目标可能在middle的左边
- 性能好、查找速度快

----

### **分治算法**

----

### **动态规划**

----

### **深度优先、回溯、广度优先**
